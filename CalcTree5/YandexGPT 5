#include <iostream>
#include <fstream>
#include <string>
using namespace std;

// Структура узла дерева
struct Node {
    int value;
    Node* left;
    Node* right;
    Node(int val) : value(val), left(nullptr), right(nullptr) {}
};

// Функция для создания узла дерева
Node* createNode(int value) {
    return new Node(value);
}

// Функция для построения дерева из префиксной записи
Node* buildTree(ifstream& file) {
    char ch;
    file >> ch;
    
    // Если это операция
    if (ch == '+') return createNode(-1);
    if (ch == '-') return createNode(-2);
    if (ch == '*') return createNode(-3);
    if (ch == '/') return createNode(-4);
    
    // Если это число
    if (isdigit(ch)) {
        return createNode(ch - '0');
    }
    
    // Создаем узел с операцией
    Node* node = createNode(ch == '+' ? -1 : (ch == '-' ? -2 : (ch == '*' ? -3 : -4)));
    
    // Рекурсивно строим левое и правое поддеревья
    node->left = buildTree(file);
    node->right = buildTree(file);
    
    return node;
}

// Функция для вычисления значения поддерева
int evaluate(Node* node) {
    if (node == nullptr) return 0;
    
    if (node->value >= 0) return node->value;
    
    int leftVal = evaluate(node->left);
    int rightVal = evaluate(node->right);
    
    switch(node->value) {
        case -1: return leftVal + rightVal;
        case -2: return leftVal - rightVal;
        case -3: return leftVal * rightVal;
        case -4: return leftVal / rightVal;
    }
    
    return 0;
}

// Функция для оптимизации дерева
Node* optimizeTree(Node* node) {
    if (node == nullptr) return nullptr;
    
    // Если это операция сложения или вычитания
    if (node->value == -1 || node->value == -2) {
        int val = evaluate(node);
        delete node;
        return createNode(val);
    }
    
    // Рекурсивно оптимизируем поддеревья
    node->left = optimizeTree(node->left);
    node->right = optimizeTree(node->right);
    
    return node;
}

int main() {
    ifstream file("filename");
    if (!file.is_open()) {
        cout << "Ошибка открытия файла" << endl;
        return 1;
    }
    
    // Строим дерево
    Node* root = buildTree(file);
    file.close();
    
    // Оптимизируем дерево
    root = optimizeTree(root);
    
    // Выводим указатель на корень
    cout << "Указатель на корень: " << root << endl;
    return 0;
}
